********************************************************************************************************
문제 풀기전
1. 문제 어떻게 풀어야할지 디테일하게 쓰기
2. 조건 꼭 쓰기
********************************************************************************************************

//arrayList -> 배열 []
return answer.stream().mapToInt(n->n).toArray();

// 인덱스 요소로 배열 정렬
Arrays.sort(arr, Comparator.comparingInt((int[] x) -> x[1]).thenComparingInt(x -> x[0]));

꼭 import java.util.*;
import java.io.*;
써주기

//힙
PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return - Integer.compare(o1,o2);
        }
    });

// 이진탐색
for (int i = 0; i <m; i++){
    boolean find = false;
    int target = sc.nextInt();
    int start = 0; // 맨 왼쪽(왼쪽 인덱스)
    int end = A.length-1; //맨 오른쪽(마지막 인덱스)
    while (start <= end) {
        int mid_index = (start + end) / 2;
        int mid_value = A[mid_index];
        if (mid_value > target) {
            end = mid_index - 1;
        } else if (mid_value < target) {
            start = mid_index + 1;
        } else { // 같이 같은경우, 즉 정답을 찾은경우
            find = true;
            break;
        }
    }

//슬라이딩 윈도우
for (int i = P; i < S; i++){ //P = 현재 부분배열의 크기, S = 전체 배열의 크기,
    // 현재 부분배열의 크기 인덱스에서 오른쪽으로 한칸씩 가겠다는 의미
    int j = i-P; // j = 맨 왼쪽, i = 맨 오른쪽 (맨 오른쪽 인덱스에서 배열길이만큼 빼면 왼쪽 인덱스값)
    Add(A[i]); // 맨 오른쪽값 추가
    Remove(A[j]); // 맨 왼쪽값 제거
    // 한번 이동을 할때마다 값이 같은지 확인
    if (checkSame == 4) result++;
}

//버블 정렬
//정렬된 값은 오른쪽에 고정. 따라서 j는 이미 정렬된 i 전까지만 루프돌면된다.
for (int i = 0; i < N-1; i++) { //루프 도는횟수는 전체 배열의 개수의 -1
    for (int j = 0; j < N-1-i; j++){
        if (A[j] > A[j+1]) {
            int temp = A[j];
            A[j] = A[j+1];
            A[j+1] = temp;
        }
    }
}


// BFS
static boolean visited[];
private static void bfs(int i, int j) {
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{i, j});
    visited[i][j] = true;
    while (!queue.isEmpty()) {
        int[] now = queue.poll();
        int x = now[0];
        int y = now[1];
        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx >= 0 && ny >= 0 && nx < n && ny < m) {
                if (graph[nx][ny] == 1 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    graph[nx][ny] = graph[x][y] + 1; // 이전 위치의 거리 + 1
                    queue.offer(new int[]{nx, ny}); // 방문한 노드를 큐에 추가
                }
            }
        }
    }
}

// DFS
private static void DFS(int now) { //현재 노드가 방문노드이면 더이상 탐색x
    if (visited[now]){
        return;
    }
    visited[now] = true;
    for(int next: A[now]){
        if (!visited[next]){
            DFS(next);
        }
    }
}

//배열의 첫 번째 요소를 제거한 새로운 배열을 반환하는 메소드
private static int[] removeElement(int[] arr) {
  // 현재보다 하나 작은사이즈의 배열선언
  int[] newArr = new int[arr.length - 1];

  // 1부터 시작하면서 차례대로 배열에 담음
  for (int i = 1; i < arr.length; i++) {
      newArr[i - 1] = arr[i];
  }

  return newArr;
}

// 큐
Queue<Integer> q = new LinkedList<>();
q.add();
q.poll();

// 스택
Stack<Integer> stack = new Stack<>();
stack.push()
stack.pop();

//투포인터
int count = 0;
// 투포인터 생성
int i = 0; // 왼쪽 인덱스(처음 인덱스)
int j = N - 1; //오른쪽 인덱스(마지막 인덱스)
while (i < j) {
    if (A[i] + A[j] < M ) i++; //합이 적으면 왼쪽인덱스 증가
    else if (A[i] + A[j] > M) j--; // 합이 크면 오른쪽 인덱스 감소
    else {
        count ++;
        i ++;
        j --;
    }
}

//투포인터2
int count = 1;
int sum = 1;
int start_index = 1;
int end_index = 1;
while (end_index != N) { // 마지막 인덱스가 아닐떄까지
    if (sum == N) {
        count ++;
        end_index++;
        sum = sum+end_index; // count 증가해줬으니깐 end_index를 증가해서 sum에다가  end_index를 더해준다.
    } else if (sum > N){
        sum = sum - start_index;
        start_index ++;
    } else {
        end_index++; sum = sum+end_index;
    }
}

// 해시
hash.put(type, hash.getOrDefault(type, 0) + 1); // 지정된 키로 매핑된 값이 없는 경우 0가져온다
// length, length() 차이 잘 확인해!1
for (int i = 0; i < phone_book.length; i++){
    for (int j = 1; j < phone_book[i].length(); j++){

hashMap.clear(); /// 꼭 중요해!!!!!

arrayList 정렬
Collections.sort() 쓴다!!
ex) Collections.sort(arrayList);

arrayList는 .size()를 쓴다

// String[] = .length